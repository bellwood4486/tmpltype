// Code generated by tmpltype; DO NOT EDIT.
package main

import (
	"fmt"
	"io"
	"sync"
	"text/template"
)

// TemplateName is a type-safe template name
type TemplateName string

// Template provides type-safe access to template names
var Template = struct {
	Footer TemplateName
	Header TemplateName
	Nav    TemplateName
}{
	Footer: "footer",
	Header: "header",
	Nav:    "nav",
}

// TemplateOption configures template initialization
type TemplateOption func(*templateConfig)

type templateConfig struct {
	funcs template.FuncMap
}

// WithFuncs sets custom template functions
func WithFuncs(funcs template.FuncMap) TemplateOption {
	return func(c *templateConfig) {
		c.funcs = funcs
	}
}

var templates map[TemplateName]*template.Template
var initOnce sync.Once

// InitTemplates initializes all templates with the given options.
// Must be called before using any render functions.
//
// Example:
//
//	InitTemplates() // without custom functions
//	InitTemplates(WithFuncs(GetTemplateFuncs())) // with custom functions
func InitTemplates(opts ...TemplateOption) {
	initOnce.Do(func() {
		config := &templateConfig{}
		for _, opt := range opts {
			opt(config)
		}

		templates = map[TemplateName]*template.Template{
			Template.Footer: newTemplate(Template.Footer, footerTplSource, config),
			Template.Header: newTemplate(Template.Header, headerTplSource, config),
			Template.Nav:    newTemplate(Template.Nav, navTplSource, config),
		}
	})
}

func newTemplate(name TemplateName, source string, config *templateConfig) *template.Template {
	t := template.New(string(name))
	if config.funcs != nil {
		t = t.Funcs(config.funcs)
	}
	return template.Must(t.Option("missingkey=error").Parse(source))
}

// Templates returns a map of all templates
func Templates() map[TemplateName]*template.Template {
	return templates
}

// Render renders a template by name with the given data
func Render(w io.Writer, name TemplateName, data any) error {
	if templates == nil {
		return fmt.Errorf("templates not initialized: call InitTemplates() first")
	}
	tmpl, ok := templates[name]
	if !ok {
		return fmt.Errorf("template %q not found", name)
	}
	return tmpl.Execute(w, data)
}

// ============================================================
// footer template
// ============================================================

type FooterLinksItem struct {
	Text string
	URL  string
}

// Footer represents parameters for footer template
type Footer struct {
	CompanyName string
	Links       []FooterLinksItem
	Year        int
}

// RenderFooter renders the footer template
func RenderFooter(w io.Writer, p Footer) error {
	if templates == nil {
		return fmt.Errorf("templates not initialized: call InitTemplates() first")
	}
	tmpl, ok := templates[Template.Footer]
	if !ok {
		return fmt.Errorf("template %q not found", Template.Footer)
	}
	return tmpl.Execute(w, p)
}

// ============================================================
// header template
// ============================================================

// Header represents parameters for header template
type Header struct {
	Subtitle *string
	Title    string
}

// RenderHeader renders the header template
func RenderHeader(w io.Writer, p Header) error {
	if templates == nil {
		return fmt.Errorf("templates not initialized: call InitTemplates() first")
	}
	tmpl, ok := templates[Template.Header]
	if !ok {
		return fmt.Errorf("template %q not found", Template.Header)
	}
	return tmpl.Execute(w, p)
}

// ============================================================
// nav template
// ============================================================

type NavItemsItem struct {
	Active bool
	Link   string
	Name   string
}

type NavCurrentUser struct {
	IsAdmin bool
	Name    string
}

// Nav represents parameters for nav template
type Nav struct {
	CurrentUser NavCurrentUser
	Items       []NavItemsItem
}

// RenderNav renders the nav template
func RenderNav(w io.Writer, p Nav) error {
	if templates == nil {
		return fmt.Errorf("templates not initialized: call InitTemplates() first")
	}
	tmpl, ok := templates[Template.Nav]
	if !ok {
		return fmt.Errorf("template %q not found", Template.Nav)
	}
	return tmpl.Execute(w, p)
}
