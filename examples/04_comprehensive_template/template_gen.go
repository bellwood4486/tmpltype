// Code generated by tmpltype; DO NOT EDIT.
package main

import (
	"fmt"
	"io"
	"sync"
	"text/template"
)

// TemplateName is a type-safe template name
type TemplateName string

// Template provides type-safe access to template names
var Template = struct {
	Advanced    TemplateName
	BasicFields TemplateName
	Collections TemplateName
	ControlFlow TemplateName
}{
	Advanced:    "advanced",
	BasicFields: "basic_fields",
	Collections: "collections",
	ControlFlow: "control_flow",
}

// TemplateOption configures template initialization
type TemplateOption func(*templateConfig)

type templateConfig struct {
	funcs template.FuncMap
}

// WithFuncs sets custom template functions
func WithFuncs(funcs template.FuncMap) TemplateOption {
	return func(c *templateConfig) {
		c.funcs = funcs
	}
}

var templates map[TemplateName]*template.Template
var initOnce sync.Once

// InitTemplates initializes all templates with the given options.
// Must be called before using any render functions.
//
// Example:
//
//	InitTemplates() // without custom functions
//	InitTemplates(WithFuncs(GetTemplateFuncs())) // with custom functions
func InitTemplates(opts ...TemplateOption) {
	initOnce.Do(func() {
		config := &templateConfig{}
		for _, opt := range opts {
			opt(config)
		}

		templates = map[TemplateName]*template.Template{
			Template.Advanced:    newTemplate(Template.Advanced, advancedTplSource, config),
			Template.BasicFields: newTemplate(Template.BasicFields, basic_fieldsTplSource, config),
			Template.Collections: newTemplate(Template.Collections, collectionsTplSource, config),
			Template.ControlFlow: newTemplate(Template.ControlFlow, control_flowTplSource, config),
		}
	})
}

func newTemplate(name TemplateName, source string, config *templateConfig) *template.Template {
	t := template.New(string(name))
	if config.funcs != nil {
		t = t.Funcs(config.funcs)
	}
	return template.Must(t.Option("missingkey=error").Parse(source))
}

// Templates returns a map of all templates
func Templates() map[TemplateName]*template.Template {
	return templates
}

// Render renders a template by name with the given data
func Render(w io.Writer, name TemplateName, data any) error {
	if templates == nil {
		return fmt.Errorf("templates not initialized: call InitTemplates() first")
	}
	tmpl, ok := templates[name]
	if !ok {
		return fmt.Errorf("template %q not found", name)
	}
	return tmpl.Execute(w, data)
}

// ============================================================
// advanced template
// ============================================================

type AdvancedCompany struct {
	Department AdvancedDepartment
}

type AdvancedDepartment struct {
	Team AdvancedTeam
}

type AdvancedManager struct {
	Name string
}

type AdvancedProject struct {
	Description string
	Name        string
	Tasks       []AdvancedTasksItem
}

type AdvancedTasksItem struct {
	Status string
	Title  string
}

type AdvancedTeam struct {
	Manager AdvancedManager
}

// Advanced represents parameters for advanced template
type Advanced struct {
	Company AdvancedCompany
	Project AdvancedProject
}

// RenderAdvanced renders the advanced template
func RenderAdvanced(w io.Writer, p Advanced) error {
	if templates == nil {
		return fmt.Errorf("templates not initialized: call InitTemplates() first")
	}
	tmpl, ok := templates[Template.Advanced]
	if !ok {
		return fmt.Errorf("template %q not found", Template.Advanced)
	}
	return tmpl.Execute(w, p)
}

// ============================================================
// basic_fields template
// ============================================================

type BasicFieldsAuthor struct {
	Email string
	Name  string
}

// BasicFields represents parameters for basic_fields template
type BasicFields struct {
	Author BasicFieldsAuthor
	Title  string
}

// RenderBasicFields renders the basic_fields template
func RenderBasicFields(w io.Writer, p BasicFields) error {
	if templates == nil {
		return fmt.Errorf("templates not initialized: call InitTemplates() first")
	}
	tmpl, ok := templates[Template.BasicFields]
	if !ok {
		return fmt.Errorf("template %q not found", Template.BasicFields)
	}
	return tmpl.Execute(w, p)
}

// ============================================================
// collections template
// ============================================================

type CollectionsItemsItem struct {
	Description string
	ID          string
	Title       string
}

type CollectionsUsersValue struct {
	Email string
	Name  string
	Role  string
}

// Collections represents parameters for collections template
type Collections struct {
	Items []CollectionsItemsItem
	Meta  map[string]string
	Users map[string]CollectionsUsersValue
}

// RenderCollections renders the collections template
func RenderCollections(w io.Writer, p Collections) error {
	if templates == nil {
		return fmt.Errorf("templates not initialized: call InitTemplates() first")
	}
	tmpl, ok := templates[Template.Collections]
	if !ok {
		return fmt.Errorf("template %q not found", Template.Collections)
	}
	return tmpl.Execute(w, p)
}

// ============================================================
// control_flow template
// ============================================================

type ControlFlowSummary struct {
	Content     string
	LastUpdated string
}

// ControlFlow represents parameters for control_flow template
type ControlFlow struct {
	DefaultMessage string
	Status         string
	Summary        ControlFlowSummary
}

// RenderControlFlow renders the control_flow template
func RenderControlFlow(w io.Writer, p ControlFlow) error {
	if templates == nil {
		return fmt.Errorf("templates not initialized: call InitTemplates() first")
	}
	tmpl, ok := templates[Template.ControlFlow]
	if !ok {
		return fmt.Errorf("template %q not found", Template.ControlFlow)
	}
	return tmpl.Execute(w, p)
}
