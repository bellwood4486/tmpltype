// Code generated by tmpltype; DO NOT EDIT.
package main

import (
	"fmt"
	"io"
	"sync"
	"text/template"
)

// TemplateName is a type-safe template name
type TemplateName string

// Template provides type-safe access to template names
var Template = struct {
	BasicTypes   TemplateName
	ComplexTypes TemplateName
	MapTypes     TemplateName
	PointerTypes TemplateName
	SliceTypes   TemplateName
	StructTypes  TemplateName
}{
	BasicTypes:   "basic_types",
	ComplexTypes: "complex_types",
	MapTypes:     "map_types",
	PointerTypes: "pointer_types",
	SliceTypes:   "slice_types",
	StructTypes:  "struct_types",
}

// TemplateOption configures template initialization
type TemplateOption func(*templateConfig)

type templateConfig struct {
	funcs template.FuncMap
}

// WithFuncs sets custom template functions
func WithFuncs(funcs template.FuncMap) TemplateOption {
	return func(c *templateConfig) {
		c.funcs = funcs
	}
}

var templates map[TemplateName]*template.Template
var initOnce sync.Once

// InitTemplates initializes all templates with the given options.
// Must be called before using any render functions.
//
// Example:
//
//	InitTemplates() // without custom functions
//	InitTemplates(WithFuncs(GetTemplateFuncs())) // with custom functions
func InitTemplates(opts ...TemplateOption) {
	initOnce.Do(func() {
		config := &templateConfig{}
		for _, opt := range opts {
			opt(config)
		}

		templates = map[TemplateName]*template.Template{
			Template.BasicTypes:   newTemplate(Template.BasicTypes, basic_typesTplSource, config),
			Template.ComplexTypes: newTemplate(Template.ComplexTypes, complex_typesTplSource, config),
			Template.MapTypes:     newTemplate(Template.MapTypes, map_typesTplSource, config),
			Template.PointerTypes: newTemplate(Template.PointerTypes, pointer_typesTplSource, config),
			Template.SliceTypes:   newTemplate(Template.SliceTypes, slice_typesTplSource, config),
			Template.StructTypes:  newTemplate(Template.StructTypes, struct_typesTplSource, config),
		}
	})
}

func newTemplate(name TemplateName, source string, config *templateConfig) *template.Template {
	t := template.New(string(name))
	if config.funcs != nil {
		t = t.Funcs(config.funcs)
	}
	return template.Must(t.Option("missingkey=error").Parse(source))
}

// Templates returns a map of all templates
func Templates() map[TemplateName]*template.Template {
	return templates
}

// Render renders a template by name with the given data
func Render(w io.Writer, name TemplateName, data any) error {
	if templates == nil {
		return fmt.Errorf("templates not initialized: call InitTemplates() first")
	}
	tmpl, ok := templates[name]
	if !ok {
		return fmt.Errorf("template %q not found", name)
	}
	return tmpl.Execute(w, data)
}

// ============================================================
// basic_types template
// ============================================================

// BasicTypes represents parameters for basic_types template
type BasicTypes struct {
	Active bool
	Age    int
	Name   string
	Price  float64
	Score  int64
}

// RenderBasicTypes renders the basic_types template
func RenderBasicTypes(w io.Writer, p BasicTypes) error {
	if templates == nil {
		return fmt.Errorf("templates not initialized: call InitTemplates() first")
	}
	tmpl, ok := templates[Template.BasicTypes]
	if !ok {
		return fmt.Errorf("template %q not found", Template.BasicTypes)
	}
	return tmpl.Execute(w, p)
}

// ============================================================
// complex_types template
// ============================================================

type ComplexTypesRecordsItem struct {
	Age   int
	Name  string
	Score *int
}

type ComplexTypesItemsItem struct {
	ID    int64
	Price float64
	Tags  []string
	Title string
}

// ComplexTypes represents parameters for complex_types template
type ComplexTypes struct {
	Items         []ComplexTypesItemsItem
	OptionalItems *[]string
	Records       []ComplexTypesRecordsItem
}

// RenderComplexTypes renders the complex_types template
func RenderComplexTypes(w io.Writer, p ComplexTypes) error {
	if templates == nil {
		return fmt.Errorf("templates not initialized: call InitTemplates() first")
	}
	tmpl, ok := templates[Template.ComplexTypes]
	if !ok {
		return fmt.Errorf("template %q not found", Template.ComplexTypes)
	}
	return tmpl.Execute(w, p)
}

// ============================================================
// map_types template
// ============================================================

// MapTypes represents parameters for map_types template
type MapTypes struct {
	Counters map[string]int
	Features map[string]bool
	Metadata map[string]string
	Prices   map[string]float64
}

// RenderMapTypes renders the map_types template
func RenderMapTypes(w io.Writer, p MapTypes) error {
	if templates == nil {
		return fmt.Errorf("templates not initialized: call InitTemplates() first")
	}
	tmpl, ok := templates[Template.MapTypes]
	if !ok {
		return fmt.Errorf("template %q not found", Template.MapTypes)
	}
	return tmpl.Execute(w, p)
}

// ============================================================
// pointer_types template
// ============================================================

// PointerTypes represents parameters for pointer_types template
type PointerTypes struct {
	Discount    *float64
	Email       *string
	MiddleScore *int
	PhoneNumber *string
}

// RenderPointerTypes renders the pointer_types template
func RenderPointerTypes(w io.Writer, p PointerTypes) error {
	if templates == nil {
		return fmt.Errorf("templates not initialized: call InitTemplates() first")
	}
	tmpl, ok := templates[Template.PointerTypes]
	if !ok {
		return fmt.Errorf("template %q not found", Template.PointerTypes)
	}
	return tmpl.Execute(w, p)
}

// ============================================================
// slice_types template
// ============================================================

// SliceTypes represents parameters for slice_types template
type SliceTypes struct {
	CategoryIDs []int
	Flags       []bool
	Ratings     []float64
	Tags        []string
}

// RenderSliceTypes renders the slice_types template
func RenderSliceTypes(w io.Writer, p SliceTypes) error {
	if templates == nil {
		return fmt.Errorf("templates not initialized: call InitTemplates() first")
	}
	tmpl, ok := templates[Template.SliceTypes]
	if !ok {
		return fmt.Errorf("template %q not found", Template.SliceTypes)
	}
	return tmpl.Execute(w, p)
}

// ============================================================
// struct_types template
// ============================================================

type StructTypesProduct struct {
	InStock bool
	Price   float64
	SKU     string
}

type StructTypesUser struct {
	Email string
	ID    int64
	Name  string
}

// StructTypes represents parameters for struct_types template
type StructTypes struct {
	Product StructTypesProduct
	User    StructTypesUser
}

// RenderStructTypes renders the struct_types template
func RenderStructTypes(w io.Writer, p StructTypes) error {
	if templates == nil {
		return fmt.Errorf("templates not initialized: call InitTemplates() first")
	}
	tmpl, ok := templates[Template.StructTypes]
	if !ok {
		return fmt.Errorf("template %q not found", Template.StructTypes)
	}
	return tmpl.Execute(w, p)
}
